---
phase: 02-server-runtime
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - api/server/router.ts
  - api/server/cors.ts
  - api/server/error-mapper.ts
  - api/server/worldmonitor/seismology/v1/handler.ts
autonomous: true
requirements:
  - SERVER-01
  - SERVER-02
  - SERVER-06

must_haves:
  truths:
    - "Router matches POST requests by method+path and returns the correct handler"
    - "CORS module returns correct headers for allowed origins and rejects disallowed origins"
    - "Error mapper converts thrown errors to appropriate HTTP status codes (400, 429, 502, 500)"
    - "Seismology handler fetches USGS GeoJSON and returns proto-shaped ListEarthquakesResponse"
  artifacts:
    - path: "api/server/router.ts"
      provides: "Map-based route matching from RouteDescriptor[]"
      exports: ["createRouter"]
    - path: "api/server/cors.ts"
      provides: "CORS header generation ported from api/_cors.js"
      exports: ["getCorsHeaders", "isDisallowedOrigin"]
    - path: "api/server/error-mapper.ts"
      provides: "Error-to-HTTP-response mapping for onError callback"
      exports: ["mapErrorToResponse"]
    - path: "api/server/worldmonitor/seismology/v1/handler.ts"
      provides: "SeismologyServiceHandler proxying USGS earthquake API"
      exports: ["seismologyHandler"]
  key_links:
    - from: "api/server/cors.ts"
      to: "api/_cors.js"
      via: "Same ALLOWED_ORIGIN_PATTERNS and logic"
      pattern: "ALLOWED_ORIGIN_PATTERNS"
    - from: "api/server/worldmonitor/seismology/v1/handler.ts"
      to: "src/generated/server/worldmonitor/seismology/v1/service_server.ts"
      via: "implements SeismologyServiceHandler interface"
      pattern: "SeismologyServiceHandler"
    - from: "api/server/error-mapper.ts"
      to: "src/generated/server/worldmonitor/seismology/v1/service_server.ts"
      via: "handles ApiError thrown by handlers"
      pattern: "ApiError"
---

<objective>
Build the shared server infrastructure modules (router, CORS, error mapper) and the first domain handler (seismology) that validates the full pipeline.

Purpose: These four modules are the building blocks that the catch-all gateway (Plan 02) will wire together. Each is small and self-contained. The seismology handler proves that generated interfaces can be implemented to proxy upstream APIs.

Output: Four TypeScript files in `api/server/` ready to be mounted by the catch-all gateway.
</objective>

<execution_context>
@/Users/sebastienmelki/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sebastienmelki/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-server-runtime/02-CONTEXT.md
@.planning/phases/02-server-runtime/02-RESEARCH.md

# Key source files to read before implementing:
@api/_cors.js
@api/earthquakes.js
@src/generated/server/worldmonitor/seismology/v1/service_server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create shared server infrastructure (router, CORS, error mapper)</name>
  <files>
    api/server/router.ts
    api/server/cors.ts
    api/server/error-mapper.ts
  </files>
  <action>
Create three small TypeScript modules using Web Standard APIs (Request/Response). No external dependencies.

**`api/server/router.ts`** — Map-based route matcher:
- Export `createRouter(allRoutes: RouteDescriptor[])` returning `{ match(req: Request): ((req: Request) => Promise<Response>) | null }`
- Build a `Map<string, handler>` keyed by `"METHOD /path"` (e.g., `"POST /api/seismology/v1/list-earthquakes"`)
- `match()` extracts pathname from `new URL(req.url)` and looks up `"${req.method} ${pathname}"`
- Define a local `RouteDescriptor` interface (same shape as generated: `{ method: string; path: string; handler: (req: Request) => Promise<Response> }`) to avoid importing from a specific generated file

**`api/server/cors.ts`** — Direct TypeScript port of `api/_cors.js`:
- Copy the exact `ALLOWED_ORIGIN_PATTERNS` array from `api/_cors.js` (worldmonitor.app, vercel previews, localhost, 127.0.0.1, tauri.localhost, tauri://, asset://)
- Export `getCorsHeaders(req: Request): Record<string, string>` — same logic as `_cors.js` but with `methods` hardcoded to `'POST, OPTIONS'` (all sebuf routes are POST)
- Export `isDisallowedOrigin(req: Request): boolean` — same logic as `_cors.js`
- Add typed `isAllowedOrigin(origin: string): boolean` as private function

**`api/server/error-mapper.ts`** — Error-to-HTTP-response mapper:
- Export `mapErrorToResponse(error: unknown, req: Request): Response` matching the `ServerOptions.onError` signature
- Handle `ApiError` pattern: check `error instanceof Error && 'statusCode' in error`, return that status code with `{ message }` body
- Handle rate-limit pattern: check for `statusCode === 429`, include `retryAfter` if present on error
- Handle upstream-down pattern: check for network/fetch errors, return 502
- Catch-all: return 500 with `{ message: "Internal server error" }` for unknown errors
- Always set `Content-Type: application/json` on error responses
- Note: `ValidationError` (400) is already handled by the generated code before `onError` is called — do NOT handle it here
  </action>
  <verify>
All three files exist and have correct TypeScript syntax. Run:
```
npx tsc --noEmit --strict --target ES2020 --module ESNext --moduleResolution bundler --lib ES2020,DOM --skipLibCheck api/server/router.ts api/server/cors.ts api/server/error-mapper.ts
```
If tsconfig issues arise from isolated compilation, verify manually that the code is valid TypeScript with correct types.
  </verify>
  <done>
- `router.ts` exports `createRouter` that builds a Map from RouteDescriptor[] and returns a match function
- `cors.ts` exports `getCorsHeaders` and `isDisallowedOrigin` with identical ALLOWED_ORIGIN_PATTERNS to `_cors.js`
- `error-mapper.ts` exports `mapErrorToResponse` handling ApiError (with statusCode), network errors (502), and unknown errors (500)
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement seismology handler as first end-to-end proof</name>
  <files>
    api/server/worldmonitor/seismology/v1/handler.ts
  </files>
  <action>
Create the seismology handler that implements `SeismologyServiceHandler` from the generated server code.

**`api/server/worldmonitor/seismology/v1/handler.ts`:**
- Import types from `../../../../../src/generated/server/worldmonitor/seismology/v1/service_server` — specifically `SeismologyServiceHandler`, `ServerContext`, `ListEarthquakesRequest`, `ListEarthquakesResponse`
- Export `seismologyHandler: SeismologyServiceHandler` as a const object implementing the interface
- `listEarthquakes` method:
  1. Fetch `https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/4.5_day.geojson` with `Accept: application/json` header
  2. If response not OK, throw `new Error('USGS API error: ${response.status}')` — the error mapper will catch this as a 500
  3. Parse JSON, extract `features` array
  4. Map each feature to the `Earthquake` shape from the generated types:
     - `id`: `feature.id`
     - `place`: `feature.properties.place || ''`
     - `magnitude`: `feature.properties.mag ?? 0`
     - `depthKm`: `feature.geometry.coordinates[2] ?? 0`
     - `location`: `{ latitude: feature.geometry.coordinates[1], longitude: feature.geometry.coordinates[0] }`
     - `occurredAt`: `String(feature.properties.time)` — int64 fields are string in generated TS
     - `sourceUrl`: `feature.properties.url || ''`
  5. Return `{ earthquakes, pagination: undefined }`
- Use `any` for the raw USGS GeoJSON types (external API shape, not worth full typing)
- Match existing `api/earthquakes.js` caching behavior: no explicit cache headers in the handler (the gateway or upstream Cache-Control handles it)
  </action>
  <verify>
File exists and implements the `SeismologyServiceHandler` interface. Verify by checking that:
1. The handler imports from the generated server types
2. All fields of `Earthquake` are populated in the mapper
3. `occurredAt` is `String(...)` not a raw number
  </verify>
  <done>
- `handler.ts` exports `seismologyHandler` implementing `SeismologyServiceHandler`
- `listEarthquakes` fetches USGS GeoJSON, transforms features to `Earthquake[]`, returns `ListEarthquakesResponse`
- Field mapping matches proto schema: id, place, magnitude, depthKm, location (lat/lng), occurredAt (string), sourceUrl
  </done>
</task>

</tasks>

<verification>
1. All four files exist in `api/server/`
2. `router.ts` creates Map-based lookup, no regex or dynamic matching
3. `cors.ts` ALLOWED_ORIGIN_PATTERNS matches `api/_cors.js` exactly
4. `error-mapper.ts` handles ApiError, network errors, and unknown errors
5. `handler.ts` implements the generated `SeismologyServiceHandler` interface
6. No Node.js-specific APIs used (no `fs`, `path`, `http`, `Buffer`) — Web Standard APIs only
7. No new npm dependencies added
</verification>

<success_criteria>
- Four TypeScript files compile without errors
- CORS patterns are identical to existing `api/_cors.js`
- Seismology handler maps all USGS GeoJSON fields to proto-shaped Earthquake objects
- All modules use Web Standard APIs compatible with Vercel Edge Runtime
</success_criteria>

<output>
After completion, create `.planning/phases/02-server-runtime/02-01-SUMMARY.md`
</output>
