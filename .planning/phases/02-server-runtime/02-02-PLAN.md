---
phase: 02-server-runtime
plan: 02
type: execute
wave: 2
depends_on:
  - "02-01"
files_modified:
  - api/[[...path]].ts
  - vite.config.ts
  - tsconfig.api.json
  - package.json
autonomous: true
requirements:
  - SERVER-03
  - SERVER-04
  - SERVER-05

must_haves:
  truths:
    - "POST to /api/seismology/v1/list-earthquakes returns earthquake data through the catch-all gateway"
    - "OPTIONS preflight to /api/seismology/v1/list-earthquakes returns 204 with CORS headers"
    - "Requests with disallowed origins are rejected with 403"
    - "Requests to non-existent sebuf routes return 404"
    - "Existing api/*.js files (e.g., /api/earthquakes) continue to work unchanged"
    - "Vite dev server handles /api/*/v1/* requests in-process without external proxy"
    - "TypeScript type-checking covers api/ files via tsconfig.api.json"
  artifacts:
    - path: "api/[[...path]].ts"
      provides: "Vercel catch-all edge function mounting all sebuf routes"
      exports: ["default", "config"]
    - path: "vite.config.ts"
      provides: "Vite dev plugin intercepting sebuf API paths"
      contains: "sebuf-api"
    - path: "tsconfig.api.json"
      provides: "TypeScript config for api/ directory type-checking"
      contains: "api"
    - path: "package.json"
      provides: "typecheck:api script"
      contains: "typecheck:api"
  key_links:
    - from: "api/[[...path]].ts"
      to: "api/server/router.ts"
      via: "imports createRouter"
      pattern: "createRouter"
    - from: "api/[[...path]].ts"
      to: "api/server/cors.ts"
      via: "imports getCorsHeaders, isDisallowedOrigin"
      pattern: "getCorsHeaders"
    - from: "api/[[...path]].ts"
      to: "api/server/error-mapper.ts"
      via: "imports mapErrorToResponse for onError"
      pattern: "mapErrorToResponse"
    - from: "api/[[...path]].ts"
      to: "api/server/worldmonitor/seismology/v1/handler.ts"
      via: "imports seismologyHandler"
      pattern: "seismologyHandler"
    - from: "api/[[...path]].ts"
      to: "src/generated/server/worldmonitor/seismology/v1/service_server.ts"
      via: "imports createSeismologyServiceRoutes"
      pattern: "createSeismologyServiceRoutes"
    - from: "vite.config.ts"
      to: "api/[[...path]].ts"
      via: "Vite plugin runs same handler logic in-process"
      pattern: "sebuf-api"
---

<objective>
Wire everything together: create the Vercel catch-all gateway that mounts all routes, add a Vite dev server plugin for local development, and set up TypeScript type-checking for the api/ directory.

Purpose: This is the integration layer that makes the server runtime work end-to-end. After this plan, a POST to `/api/seismology/v1/list-earthquakes` returns real earthquake data in both dev (Vite) and production (Vercel Edge).

Output: Working end-to-end pipeline from HTTP request through catch-all gateway to seismology handler and back.
</objective>

<execution_context>
@/Users/sebastienmelki/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sebastienmelki/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-server-runtime/02-CONTEXT.md
@.planning/phases/02-server-runtime/02-RESEARCH.md
@.planning/phases/02-server-runtime/02-01-SUMMARY.md

# Key source files:
@api/server/router.ts
@api/server/cors.ts
@api/server/error-mapper.ts
@api/server/worldmonitor/seismology/v1/handler.ts
@src/generated/server/worldmonitor/seismology/v1/service_server.ts
@vite.config.ts
@tsconfig.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Vercel catch-all gateway and tsconfig for api/</name>
  <files>
    api/[[...path]].ts
    tsconfig.api.json
    package.json
  </files>
  <action>
**`api/[[...path]].ts`** — Vercel catch-all edge function:
- `export const config = { runtime: 'edge' };`
- Static imports at top (no dynamic imports — breaks edge bundling):
  - `createRouter` from `./server/router`
  - `getCorsHeaders`, `isDisallowedOrigin` from `./server/cors`
  - `mapErrorToResponse` from `./server/error-mapper`
  - `createSeismologyServiceRoutes` from `../src/generated/server/worldmonitor/seismology/v1/service_server`
  - `seismologyHandler` from `./server/worldmonitor/seismology/v1/handler`
- Create `serverOptions = { onError: mapErrorToResponse }`
- Create route array: `const allRoutes = [...createSeismologyServiceRoutes(seismologyHandler, serverOptions)]`
  - Add a comment: `// Add more domains here as handlers are implemented in Phase 2C-2S`
- Create router: `const router = createRouter(allRoutes)`
- Export default async handler function:
  1. `const corsHeaders = getCorsHeaders(request)`
  2. OPTIONS preflight: return `new Response(null, { status: 204, headers: corsHeaders })`
  3. Origin check: if `isDisallowedOrigin(request)`, return 403 with `{ error: 'Origin not allowed' }` and CORS headers
  4. Route matching: `const matchedHandler = router.match(request)`, if null return 404 with `{ error: 'Not found' }` and CORS headers
  5. Execute handler: `const response = await matchedHandler(request)`
  6. Merge CORS headers into response: create new `Headers` from `response.headers`, set all CORS headers, return `new Response(response.body, { status: response.status, statusText: response.statusText, headers: mergedHeaders })`
  7. This CORS merging pattern ensures CORS headers appear on EVERY response including errors — addressing Pitfall 2 from research

**`tsconfig.api.json`** — Separate tsconfig for api/ directory:
- Extends `./tsconfig.json`
- Override `compilerOptions`: remove `"types": ["vite/client"]` (not needed in edge runtime), keep all other strict settings
- `include: ["api", "src/generated"]` — needs generated types for imports
- Do NOT include `src/` (would pull in Vite client types)
- This is option (a) from the research — avoids mixing Vite client types with edge function types

**`package.json`** — Add typecheck:api script:
- Add `"typecheck:api": "tsc --noEmit -p tsconfig.api.json"` to scripts
- Do NOT modify any other scripts or dependencies
  </action>
  <verify>
1. Run `npx tsc --noEmit -p tsconfig.api.json` and verify it succeeds (or shows only pre-existing issues from generated code)
2. Verify `api/[[...path]].ts` has `export const config = { runtime: 'edge' }` and `export default`
3. Verify all imports are static (no dynamic imports)
4. Verify CORS headers are merged into every response path (200, 204, 403, 404)
  </verify>
  <done>
- `api/[[...path]].ts` mounts seismology routes via catch-all pattern with CORS + error handling
- `tsconfig.api.json` enables type-checking for api/ files with generated types
- `package.json` has `typecheck:api` script
- All response paths include CORS headers
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Vite dev server plugin for sebuf API routes</name>
  <files>
    vite.config.ts
  </files>
  <action>
Add a `sebufApiPlugin()` Vite plugin to `vite.config.ts` that intercepts sebuf API requests during local development.

**Plugin implementation:**
- Create a new function `sebufApiPlugin(): Plugin` in `vite.config.ts` (follows the pattern of existing `youtubeLivePlugin()`)
- Use `configureServer(server)` hook with `server.middlewares.use()`
- Only intercept requests matching `/api/[a-z]+/v1/` pattern (sebuf routes). All other `/api/*` paths fall through to existing proxies
- Convert Connect's `IncomingMessage` to a Web Standard `Request`:
  1. Build URL from `req.url` and `http://localhost:${server.config.server.port || 3000}`
  2. Read body for POST requests: collect chunks from `req` stream into a Buffer, convert to string
  3. Create `new Request(url, { method: req.method, headers: extractedHeaders, body: bodyString })`
- Import the same modules used by the catch-all gateway:
  - `createRouter` from `./api/server/router`
  - `getCorsHeaders`, `isDisallowedOrigin` from `./api/server/cors`
  - `mapErrorToResponse` from `./api/server/error-mapper`
  - `createSeismologyServiceRoutes` from `./src/generated/server/worldmonitor/seismology/v1/service_server`
  - `seismologyHandler` from `./api/server/worldmonitor/seismology/v1/handler`
- IMPORTANT: These imports may cause issues in vite.config.ts since it's loaded before the dev server starts. If static imports fail, use dynamic `import()` inside `configureServer` to lazily load the handler modules. This is acceptable because the Vite plugin runs server-side (not edge), so dynamic imports work fine.
- Build route table and router the same way as the catch-all gateway
- Execute matched handler, write response to Connect's `ServerResponse`:
  1. `res.statusCode = response.status`
  2. Set headers from Response
  3. Write body: `res.end(await response.text())`
- If no route matches, call `next()` to fall through to Vite's other handlers/proxies

**Plugin registration:**
- Add `sebufApiPlugin()` to the `plugins` array in `defineConfig`, BEFORE the proxy config takes effect (place after `youtubeLivePlugin()`)
- The plugin only handles `/api/*/v1/*`, so existing proxy rules for `/api/earthquake`, `/api/yahoo`, etc. are unaffected (those paths don't match the pattern)

**Important notes:**
- The plugin uses `req` (Connect IncomingMessage) not `Request` — must convert
- For body reading, use: `const chunks: Buffer[] = []; for await (const chunk of req) chunks.push(chunk); const body = Buffer.concat(chunks).toString();`
- Set CORS headers on all plugin responses (matching catch-all gateway behavior)
- Use `return` after writing response (don't call `next()` after responding)
  </action>
  <verify>
1. Run `npm run dev` and confirm the dev server starts without errors
2. `curl -X POST http://localhost:3000/api/seismology/v1/list-earthquakes -H 'Content-Type: application/json' -d '{}'` should return earthquake data
3. Existing proxy routes (e.g., `/api/earthquake/earthquakes/feed/v1.0/summary/4.5_day.geojson`) should still work
4. `curl -X OPTIONS http://localhost:3000/api/seismology/v1/list-earthquakes -H 'Origin: http://localhost:3000'` should return 204 with CORS headers
  </verify>
  <done>
- Vite dev server intercepts `/api/*/v1/*` requests and routes them through the same handler pipeline
- Existing Vite proxy rules for `/api/earthquake`, `/api/yahoo`, etc. remain unaffected
- POST to `/api/seismology/v1/list-earthquakes` in dev returns real USGS earthquake data
- CORS headers applied to all dev server responses
  </done>
</task>

</tasks>

<verification>
1. `api/[[...path]].ts` exists with edge runtime config and exports default handler
2. All imports are static in the catch-all gateway
3. CORS headers appear on every response (200, 204, 403, 404)
4. `tsconfig.api.json` exists and `tsc --noEmit -p tsconfig.api.json` passes
5. `package.json` has `typecheck:api` script
6. Vite plugin intercepts `/api/*/v1/*` and falls through for other paths
7. Existing `api/*.js` files are not affected (Vercel routing priority confirmed)
8. Tauri sidecar automatically picks up new catch-all (no sidecar changes needed - SERVER-05)
</verification>

<success_criteria>
- POST to `/api/seismology/v1/list-earthquakes` returns earthquake data through the catch-all (dev mode via Vite plugin)
- OPTIONS preflight returns 204 with CORS headers
- Disallowed origins get 403
- Unknown routes get 404
- Existing `api/*.js` endpoints unaffected
- `npm run typecheck:api` passes (or only shows pre-existing issues)
</success_criteria>

<output>
After completion, create `.planning/phases/02-server-runtime/02-02-SUMMARY.md`
</output>
